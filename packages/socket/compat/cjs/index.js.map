{"version":3,"file":"index.js","sources":["../../src/notifier/find.js","../../src/createPushHandler.js","../../src/handlePush.js","../../src/notifier/notify.js","../../src/notifier/findIndex.js","../../src/notifier/remove.js","../../src/updateNotifiers.js","../../src/cancel.js","../../src/notifier/notifyAll.js","../../src/notifier/refresh.js","../../src/pushRequest.js","../../src/joinChannel.js","../../src/create.js","../../src/notifier/observe.js","../../src/observe.js","../../src/notifier/create.js","../../src/send.js","../../src/toObservable.js","../../src/notifier/unobserve.js","../../src/unobserve.js"],"sourcesContent":["// @flow\n\nimport {hasIn} from \"@jumpn/utils-composite\";\n\nimport type {Notifier} from \"../types\";\n\nconst find = (notifiers: Array<Notifier<any>>, key: string, value: any) =>\n  // $FlowFixMe: flow is having some troubles to match hasIn signature (curry)\n  notifiers.find(hasIn([key], value));\n\nexport default find;\n","// @flow\n\nimport {map} from \"@jumpn/utils-composite\";\n\nimport type {GqlRequest} from \"@jumpn/utils-graphql/compat/cjs/types\";\n\nimport notifierFind from \"./notifier/find\";\n\nimport type {AbsintheSocket, NotifierPushHandler, PushHandler} from \"./types\";\n\nconst createEventHandler = (absintheSocket, request) => handle => (...args) => {\n  const notifier = notifierFind(absintheSocket.notifiers, \"request\", request);\n\n  if (notifier) {\n    handle(absintheSocket, notifier, ...args);\n  }\n};\n\nconst createPushHandler = <Response: Object>(\n  notifierPushHandler: NotifierPushHandler<Response>,\n  absintheSocket: AbsintheSocket,\n  request: GqlRequest<any>\n): PushHandler<Response> =>\n  map(createEventHandler(absintheSocket, request), notifierPushHandler);\n\nexport default createPushHandler;\n","// @flow\n\nimport {Push} from \"phoenix\";\n\nimport type {PushHandler} from \"./types\";\n\nconst handlePush = (push: Push, handler: PushHandler<any>) =>\n  push\n    .receive(\"ok\", handler.onSucceed)\n    .receive(\"error\", handler.onError)\n    .receive(\"timeout\", handler.onTimeout);\n\nexport default handlePush;\n","// @flow\n\nimport type {Event, Notifier} from \"../types\";\n\nconst getNotifier = (handlerName, data) => observer =>\n  observer[handlerName] && observer[handlerName](data);\n\nconst getHandlerName = event => `on${event}`;\n\nconst notify = (notifier: Notifier<any>, event: Event, data: any) =>\n  notifier.observers.forEach(getNotifier(getHandlerName(event), data));\n\nexport default notify;\n","// @flow\n\nimport {hasIn} from \"@jumpn/utils-composite\";\n\nimport type {Notifier} from \"../types\";\n\nconst findIndex = (notifiers: Array<Notifier<any>>, key: string, value: any) =>\n  // $FlowFixMe: flow is having some troubles to match hasIn signature (curry)\n  notifiers.findIndex(hasIn([key], value));\n\nexport default findIndex;\n","// @flow\n\nimport {remove as arrayRemove} from \"@jumpn/utils-array\";\n\nimport findIndex from \"./findIndex\";\n\nimport type {Notifier} from \"../types\";\n\nconst remove = (notifier: Notifier<any>) => (notifiers: Array<Notifier<any>>) =>\n  arrayRemove(findIndex(notifiers, \"request\", notifier.request), 1, notifiers);\n\nexport default remove;\n","// @flow\n\nimport type {AbsintheSocket, Notifier} from \"./types\";\n\ntype Notifiers = Array<Notifier<any>>;\n\nconst updateNotifiers = (\n  absintheSocket: AbsintheSocket,\n  updater: (notifiers: Notifiers) => Notifiers\n) => {\n  absintheSocket.notifiers = updater(absintheSocket.notifiers);\n\n  return absintheSocket;\n};\n\nexport default updateNotifiers;\n","// @flow\n\nimport createPushHandler from \"./createPushHandler\";\nimport handlePush from \"./handlePush\";\nimport notifierNotify from \"./notifier/notify\";\nimport notifierRemove from \"./notifier/remove\";\nimport updateNotifiers from \"./updateNotifiers\";\n\nimport type {AbsintheSocket, Notifier, NotifierPushHandler} from \"./types\";\n\n// TODO: improve this type\ntype UnsubscribeResponse = {};\n\nconst removeNotifiers = (absintheSocket, notifier) => {\n  updateNotifiers(absintheSocket, notifierRemove(notifier));\n\n  notifierNotify(notifier, \"Cancel\", notifier);\n};\n\nconst onError = (absintheSocket, notifier, errorMessage) => {\n  // eslint-disable-next-line no-use-before-define\n  unsubscribe(absintheSocket, notifier);\n\n  notifierNotify(notifier, \"Error\", `unsubscribe: ${errorMessage}`);\n};\n\nconst onTimeout = (absintheSocket, notifier) =>\n  notifierNotify(notifier, \"Error\", \"unsubscribe: timeout\");\n\nconst notifierPushHandler: NotifierPushHandler<UnsubscribeResponse> = {\n  onError,\n  onTimeout,\n  onSucceed: removeNotifiers\n};\n\nconst unsubscribe = (absintheSocket, notifier) =>\n  handlePush(\n    absintheSocket.channel.push(\"unsubscribe\", {\n      subscriptionId: notifier.subscriptionId\n    }),\n    createPushHandler(notifierPushHandler, absintheSocket, notifier.request)\n  );\n\n/**\n * Cancels a notifier sending a Cancel event to all its observers and\n * unsubscribing in case it holds a subscription request\n *\n * @example\n * import * as AbsintheSocket from \"@absinthe/socket\";\n * \n * AbsintheSocket.cancel(absintheSocket, notifier);\n */\nconst cancel = (\n  absintheSocket: AbsintheSocket,\n  notifier: Notifier<any>\n): AbsintheSocket => {\n  if (notifier.operationType === \"subscription\") {\n    unsubscribe(absintheSocket, notifier);\n  } else {\n    removeNotifiers(absintheSocket, notifier);\n  }\n\n  return absintheSocket;\n};\n\nexport default cancel;\n","// @flow\n\nimport notify from \"./notify\";\n\nimport type {Event, Notifier} from \"../types\";\n\nconst notifyall = (notifiers: Array<Notifier<any>>, event: Event, data: any) =>\n  notifiers.forEach(notifier => notify(notifier, event, data));\n\nexport default notifyall;\n","// @flow\n\nimport {replace as arrayReplace} from \"@jumpn/utils-array\";\n\nimport findIndex from \"./findIndex\";\n\nimport type {Notifier} from \"../types\";\n\nconst refresh = (notifier: Notifier<any>) => (\n  notifiers: Array<Notifier<any>>\n) =>\n  arrayReplace(\n    findIndex(notifiers, \"request\", notifier.request),\n    [notifier],\n    notifiers\n  );\n\nexport default refresh;\n","// @flow\n\nimport {\n  errorsToString as gqlErrorsToString,\n  requestToCompat\n} from \"@jumpn/utils-graphql\";\n\nimport type {\n  GqlError,\n  GqlResponse\n} from \"@jumpn/utils-graphql/compat/cjs/types\";\n\nimport createPushHandler from \"./createPushHandler\";\nimport handlePush from \"./handlePush\";\nimport notifierNotify from \"./notifier/notify\";\nimport notifierRemove from \"./notifier/remove\";\nimport notifierRefresh from \"./notifier/refresh\";\nimport updateNotifiers from \"./updateNotifiers\";\n\nimport type {AbsintheSocket, Notifier, NotifierPushHandler} from \"./types\";\n\ntype SubscriptionResponse =\n  | {|subscriptionId: string|}\n  | {|errors: Array<GqlError>|};\n\nconst notifyStart = notifier => notifierNotify(notifier, \"Start\", notifier);\n\nconst onSubscriptionSucceed = (absintheSocket, notifier, {subscriptionId}) => {\n  const updatedNotifier = {...notifier, subscriptionId};\n\n  updateNotifiers(absintheSocket, notifierRefresh(updatedNotifier));\n\n  notifyStart(updatedNotifier);\n};\n\nconst abortRequest = (absintheSocket, notifier, error) => {\n  updateNotifiers(absintheSocket, notifierRemove(notifier));\n\n  notifierNotify(notifier, \"Abort\", error);\n};\n\nconst onError = (absintheSocket, notifier, errorMessage) =>\n  abortRequest(absintheSocket, notifier, new Error(JSON.stringify(errorMessage)));\n\nconst onSubscriptionResponse = (absintheSocket, notifier, response) => {\n  if (response.errors) {\n    onError(absintheSocket, notifier, gqlErrorsToString(response.errors));\n  } else {\n    onSubscriptionSucceed(absintheSocket, notifier, response);\n  }\n};\n\nconst onQueryOrMutationResponse = (absintheSocket, notifier, response) => {\n  updateNotifiers(absintheSocket, notifierRemove(notifier));\n\n  notifierNotify(notifier, \"Result\", response);\n};\n\nconst onTimeout = (absintheSocket, notifier) =>\n  notifierNotify(notifier, \"Error\", new Error(\"request: timeout\"));\n\nconst queryOrMutationHandler: NotifierPushHandler<GqlResponse<any>> = {\n  onError,\n  onTimeout,\n  onSucceed: onQueryOrMutationResponse\n};\n\nconst subcriptionHandler: NotifierPushHandler<SubscriptionResponse> = {\n  onError,\n  onTimeout,\n  onSucceed: onSubscriptionResponse\n};\n\nconst send = (absintheSocket, request, notifierPushHandler) =>\n  handlePush(\n    absintheSocket.channel.push(\"doc\", requestToCompat(request)),\n    createPushHandler(notifierPushHandler, absintheSocket, request)\n  );\n\nconst pushRequest = (\n  absintheSocket: AbsintheSocket,\n  notifier: Notifier<any>\n) => {\n  if (notifier.operationType === \"subscription\") {\n    send(absintheSocket, notifier.request, subcriptionHandler);\n  } else {\n    notifyStart(notifier);\n    send(absintheSocket, notifier.request, queryOrMutationHandler);\n  }\n};\n\nexport default pushRequest;\n","// @flow\n\nimport handlePush from \"./handlePush\";\nimport notifierNotifyAll from \"./notifier/notifyAll\";\nimport pushRequest from \"./pushRequest\";\n\nimport type {AbsintheSocket} from \"./types\";\n\n// join Push is reused and so the handler\n// https://github.com/phoenixframework/phoenix/blob/master/assets/js/phoenix.js#L356\nconst createChannelJoinHandler = absintheSocket => ({\n  onError: (errorMessage: string) =>\n    notifierNotifyAll(\n      absintheSocket.notifiers,\n      \"Error\",\n      new Error(`channel join: ${errorMessage}`)\n    ),\n\n  onSucceed: () =>\n    absintheSocket.notifiers.forEach(notifier =>\n      pushRequest(absintheSocket, notifier)\n    ),\n\n  onTimeout: () =>\n    notifierNotifyAll(\n      absintheSocket.notifiers,\n      \"Error\",\n      new Error(\"channel join: timeout\")\n    )\n});\n\nconst joinChannel = (absintheSocket: AbsintheSocket) => {\n  handlePush(\n    absintheSocket.channel.join(),\n    createChannelJoinHandler(absintheSocket)\n  );\n\n  absintheSocket.channelJoinCreated = true;\n\n  return absintheSocket;\n};\n\nexport default joinChannel;\n","// @flow\n\nimport {Socket as PhoenixSocket} from \"phoenix\";\n\nimport type {Message} from \"phoenix\";\n\nimport joinChannel from \"./joinChannel\";\nimport notifierFind from \"./notifier/find\";\nimport notifierNotify from \"./notifier/notify\";\nimport notifierRemove from \"./notifier/remove\";\nimport updateNotifiers from \"./updateNotifiers\";\n\nimport type {AbsintheSocket, SubscriptionPayload} from \"./types\";\n\nconst createConnectionCloseError = () => new Error(\"connection: close\");\n\nconst mutationOnConnectionClose = (absintheSocket, notifier) => {\n  updateNotifiers(absintheSocket, notifierRemove(notifier));\n\n  notifierNotify(notifier, \"Abort\", createConnectionCloseError());\n};\n\nconst notifierOnConnectionClose = absintheSocket => notifier => {\n  if (notifier.operationType === \"mutation\") {\n    mutationOnConnectionClose(absintheSocket, notifier);\n  } else {\n    notifierNotify(notifier, \"Error\", createConnectionCloseError());\n  }\n};\n\nconst onConnectionClose = absintheSocket => () =>\n  absintheSocket.notifiers.forEach(notifierOnConnectionClose(absintheSocket));\n\nconst onSubscriptionData = (\n  absintheSocket: AbsintheSocket,\n  {payload}: Message<SubscriptionPayload<any>>\n) => {\n  const notifier = notifierFind(\n    absintheSocket.notifiers,\n    \"subscriptionId\",\n    payload.subscriptionId\n  );\n\n  if (notifier) {\n    notifierNotify(notifier, \"Result\", payload.result);\n  }\n};\n\nconst onMessage = absintheSocket => (response: Message<>) => {\n  if (response.event === \"subscription:data\") {\n    onSubscriptionData(absintheSocket, response);\n  }\n};\n\nconst shouldJoinChannel = absintheSocket =>\n  !absintheSocket.channelJoinCreated && absintheSocket.notifiers.length > 0;\n\nconst onConnectionOpen = absintheSocket => () => {\n  if (shouldJoinChannel(absintheSocket)) {\n    joinChannel(absintheSocket);\n  }\n};\n\nconst absintheChannelName = \"__absinthe__:control\";\n\n/**\n * Creates an Absinthe Socket using the given Phoenix Socket instance\n *\n * @example\n * import * as AbsintheSocket from \"@absinthe/socket\";\n * import {Socket as PhoenixSocket} from \"phoenix\";\n\n * const absintheSocket = AbsintheSocket.create(\n *   new PhoenixSocket(\"ws://localhost:4000/socket\")\n * );\n */\nconst create = (phoenixSocket: PhoenixSocket): AbsintheSocket => {\n  const absintheSocket: AbsintheSocket = {\n    phoenixSocket,\n    channel: phoenixSocket.channel(absintheChannelName),\n    channelJoinCreated: false,\n    notifiers: []\n  };\n\n  phoenixSocket.onOpen(onConnectionOpen(absintheSocket));\n  phoenixSocket.onMessage(onMessage(absintheSocket));\n  phoenixSocket.onClose(onConnectionClose(absintheSocket));\n\n  return absintheSocket;\n};\n\nexport default create;\n","// @flow\n\nimport type {Notifier, Observer} from \"../types\";\n\nconst observe = <Result>(\n  {observers, ...rest}: Notifier<Result>,\n  observer: Observer<Result>\n) => ({\n  ...rest,\n  observers: [...observers, observer]\n});\n\nexport default observe;\n","// @flow\n\nimport notifierObserve from \"./notifier/observe\";\nimport notifierRefresh from \"./notifier/refresh\";\nimport updateNotifiers from \"./updateNotifiers\";\n\nimport type {AbsintheSocket, Notifier, Observer} from \"./types\";\n\n/**\n * Observes given notifier using the provided observer\n *\n * @example\n * import AbsintheSocket from \"@absinthe/socket\"\n *\n * const logEvent = eventName => (...args) => console.log(eventName, ...args);\n *\n * const updatedNotifier = AbsintheSocket.observe(absintheSocket, notifier, {\n *   onAbort: logEvent(\"abort\"),\n *   onError: logEvent(\"error\"),\n *   onStart: logEvent(\"open\"),\n *   onResult: logEvent(\"result\")\n * });\n */\nconst observe = <Result>(\n  absintheSocket: AbsintheSocket,\n  notifier: Notifier<Result>,\n  observer: Observer<Result>\n): AbsintheSocket =>\n  updateNotifiers(\n    absintheSocket,\n    notifierRefresh(notifierObserve(notifier, observer))\n  );\n\nexport default observe;\n","// @flow\n\nimport {getOperationType} from \"@jumpn/utils-graphql\";\n\nimport type {GqlRequest, Notifier} from \"../types\";\n\nconst create = (request: GqlRequest<any>): Notifier<*> => ({\n  request,\n  observers: [],\n  operationType: getOperationType(request.operation),\n  subscriptionId: undefined\n});\n\nexport default create;\n","// @flow\n\nimport {append} from \"@jumpn/utils-array\";\n\nimport joinChannel from \"./joinChannel\";\nimport notifierCreate from \"./notifier/create\";\nimport notifierFind from \"./notifier/find\";\nimport pushRequest from \"./pushRequest\";\nimport updateNotifiers from \"./updateNotifiers\";\n\nimport type {AbsintheSocket, GqlRequest, Notifier} from \"./types\";\n\nconst connectOrJoinChannel = absintheSocket => {\n  if (absintheSocket.phoenixSocket.isConnected()) {\n    joinChannel(absintheSocket);\n  } else {\n    // socket ignores connect calls if a connection has already been created\n    absintheSocket.phoenixSocket.connect();\n  }\n};\n\nconst sendNew = (absintheSocket, request) => {\n  const notifier = notifierCreate(request);\n\n  updateNotifiers(absintheSocket, append([notifier]));\n\n  if (absintheSocket.channelJoinCreated) {\n    pushRequest(absintheSocket, notifier);\n  } else {\n    connectOrJoinChannel(absintheSocket);\n  }\n\n  return notifier;\n};\n\n/**\n * Sends given request and returns an object (notifier) to track its progress\n * (see observe function)\n *\n * @example\n * import * as AbsintheSocket from \"@absinthe/socket\";\n *\n * const operation = `\n *   subscription userSubscription($userId: ID!) {\n *     user(userId: $userId) {\n *       id\n *       name\n *     }\n *   }\n * `;\n *\n * // This example uses a subscription, but the functionallity is the same for\n * // all operation types (queries, mutations and subscriptions)\n *\n * const notifier = AbsintheSocket.send(absintheSocket, {\n *   operation,\n *   variables: {userId: 10}\n * });\n */\nconst send = (\n  absintheSocket: AbsintheSocket,\n  request: GqlRequest<*>\n): Notifier<*> =>\n  notifierFind(absintheSocket.notifiers, \"request\", request) ||\n  sendNew(absintheSocket, request);\n\nexport default send;\n","// @flow\n\nimport Observable from \"zen-observable\";\n\nimport observe from \"./observe\";\n\nimport type {AbsintheSocket, Notifier, Observer} from \"./types\";\n\ntype Options<Result> = {\n  unsubscribe: () => void,\n  onError: $PropertyType<Observer<Result>, \"onError\">,\n  onStart: $PropertyType<Observer<Result>, \"onStart\">\n};\n\nconst onResult = (notifier, observer) => result => {\n  observer.next(result);\n\n  if (notifier.operationType !== \"subscription\") {\n    observer.complete();\n  }\n};\n\n/**\n * Creates an Observable that will follow the given notifier\n *\n * @param {AbsintheSocket} absintheSocket\n * @param {Notifier<Result>} notifier\n * @param {Object} [options]\n * @param {function(error: Error): undefined} [options.onError]\n * @param {function(notifier: Notifier<Result>): undefined} [options.onStart]\n * @param {function(): undefined} [options.unsubscribe]\n *\n * @return {Observable}\n */\nconst toObservable = <Result>(\n  absintheSocket: AbsintheSocket,\n  notifier: Notifier<Result>,\n  {onError, onStart, unsubscribe}: $Shape<Options<Result>> = {}\n) =>\n  new Observable(observer => {\n    observe(absintheSocket, notifier, {\n      onError,\n      onStart,\n      onAbort: observer.error,\n      onResult: onResult(notifier, observer)\n    });\n\n    return unsubscribe;\n  });\n\nexport default toObservable;\n","// @flow\n\nimport {remove as arrayRemove} from \"@jumpn/utils-array\";\n\nimport type {Notifier, Observer} from \"../types\";\n\nconst unobserve = <Result>(\n  {observers, ...rest}: Notifier<Result>,\n  observer: Observer<Result>\n) => ({\n  ...rest,\n  observers: arrayRemove(observers.indexOf(observer), 1, observers)\n});\n\nexport default unobserve;\n","// @flow\n\nimport notifierRefresh from \"./notifier/refresh\";\nimport notifierUnobserve from \"./notifier/unobserve\";\nimport updateNotifiers from \"./updateNotifiers\";\n\nimport type {AbsintheSocket, Notifier, Observer} from \"./types\";\n\n/**\n * Detaches observer from notifier\n *\n * @example\n * import * as AbsintheSocket from \"@absinthe/socket\";\n *\n * AbsintheSocket.unobserve(absintheSocket, notifier, observer);\n */\nconst unobserve = (\n  absintheSocket: AbsintheSocket,\n  notifier: Notifier<any>,\n  observer: Observer<any>\n): AbsintheSocket => {\n  updateNotifiers(\n    absintheSocket,\n    notifierRefresh(notifierUnobserve(notifier, observer))\n  );\n\n  return absintheSocket;\n};\n\nexport default unobserve;\n"],"names":["find","notifiers","key","value","hasIn","createEventHandler","absintheSocket","request","args","notifier","notifierFind","createPushHandler","notifierPushHandler","map","handlePush","push","handler","receive","onSucceed","onError","onTimeout","getNotifier","handlerName","data","observer","getHandlerName","event","notify","observers","forEach","findIndex","remove","arrayRemove","updateNotifiers","updater","removeNotifiers","notifierRemove","errorMessage","notifierNotify","unsubscribe","channel","subscriptionId","cancel","operationType","notifyall","refresh","arrayReplace","notifyStart","onSubscriptionSucceed","updatedNotifier","notifierRefresh","abortRequest","error","Error","_JSON$stringify","onSubscriptionResponse","response","errors","gqlErrorsToString","onQueryOrMutationResponse","queryOrMutationHandler","subcriptionHandler","send","requestToCompat","pushRequest","createChannelJoinHandler","notifierNotifyAll","joinChannel","join","channelJoinCreated","createConnectionCloseError","mutationOnConnectionClose","notifierOnConnectionClose","onConnectionClose","onSubscriptionData","payload","result","onMessage","shouldJoinChannel","length","onConnectionOpen","absintheChannelName","create","phoenixSocket","onOpen","onClose","observe","rest","notifierObserve","getOperationType","operation","undefined","connectOrJoinChannel","isConnected","connect","sendNew","notifierCreate","append","onResult","next","complete","toObservable","onStart","Observable","unobserve","indexOf","notifierUnobserve"],"mappings":"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"}